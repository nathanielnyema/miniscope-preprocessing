# miniscope data preprocessing pipeline
This repository contains code for the preprocessing of miniature microscope recordings. The pipeline uses the CaImAn python package to perform motion correction and deconvolution using the OnACID-E algorithm. Be sure to create a conda environment called `caiman` following the instructions in the CaImAn documentation before using this code. Some additional requirements worth conda installing in the event the default caiman installation do not come with it are: seaborn, pandas, ffmpeg. We've chosen this online algorithm due to the length of the recordings produced by our experiments (approximately 8 hours long) which presents significant memory challenges for batch processing of the entire dataset with the popular CNMF-E algorithm. Typically we may downsample the data by a factor of 4 then split the videos into 2 hour chunks and analyze each chunk separately. The trouble is we then need to register the components accross chunks of the data. Using OnACID-E we may analyze the entire dataset at once. The important files in this folder are as follows

* `filter.sh` - a shell script that uses ffmpeg to downsample the input video by averaging every 4 frames together and speeds up the resulting video by a factor of 10 such that we may approximate the calcium transients in the CNMF-E with a less computationally instensive first order autoregressive process despite the use of GCaMP6s. 
* `/notebooks/miniscope_parameter_screen.ipynb` - a notebook for experimenting with parameters for the algorithm. A block of code in this notebook creates a file called `opts.npy` with the parameters for the algorithm.
* `preprocess.py` - a python script with several useful functions for preprocessing. The first of these that gets used is a function named `print_fr` which simply prints the frame rate of the specified video to stdout, such that it can be later fed into ffmpeg as an argument. The next, and most important function is `run_pipeline_online`, which reads in an opts.npy file with parameters for OnACID-E and feeds them to the algorithm to run the pipeine on the input video. Lastly, `apply_shifts_online_cust` is a custom version of the `apply_shifts_online` function in CaImAn that does not attempt to load the entire movie array into memory before applying the shifts. The function then saves a memmap with the motion corrected frames that one may use to compute a local correlation map of the movie in posthoc analyses.
* `run_pipeline.sh` - a shell/slurm script for running the entire pipeline. If run locally as a shell script, one must first export an environemt variable named `FPATH` and assign to it the path to the video you would like to analyze. For example:  `export FPATH = /path/to/video`. Then you simply run `bash run_pipeline.sh` to run the pipeline. If running this as a slurm script, the sbatch call should specify the expected time limit for the job and should export the variable FPATH as follows 
```
sbatch --time 12:00:00 --export=ALL,FPATH=/path/to/video
```
* `posthoc.ipynb` - a notebook with code for loading the saved cnmf results, computing a local correlation map for the motion corrected video, and filtering rois based on certain exclusion criteria.
